// В программе определяется функция bar. Требуется вывести первые X байт ее кода.

#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

enum { BYTES_TO_PRINT = 100 };

// функция принимает int, увеличивает его на константу и выводит значение на экран
static void bar(int x) {
	x += 6;

	// Макрос __func__ содержит имя текущей функции
	// __LINE__ -- номер текущей строки
	printf("%s/%d: x = %d\n", __func__, __LINE__, x);
}

// Определяем новый тип данных bar_func_t: указатель на функцию,
// которая ничего не возвращает и принимает int аргумент
typedef void(bar_func_t)(int);

int main(void) {
	int ret = 0;

	// /proc/<pid>/mem -- файл, представляющий собой адресное пространство
	// с номером pid.
	//
	// В файловой системе procfs для текущего процесса существует
	// специальная директория -- /proc/self
	int fd = open("/proc/self/mem", O_RDONLY);
	if (fd < 0) {
		perror("open failed");
		return EXIT_FAILURE;
	}

	// Просто для примера выведем адрес функции на экран
	//
	// Имя функции является указателем на нее
	// При компиляции с -pedantic происходит ошибка, если
	// сохранять указатель на функцию в void*. Чтобы этого
	// избежать, мы завели отдельный тип данных.
	//
	// В формате printf нет спецификатора для "указателя на функцию",
	// а использование %p требует void*.
	// Поэтому мы используем uintptr_t: тип данных, в который может
	// быть преобразован любой void*.
	//
	// Длина этого типа данных может быть разной на разных архитектурах,
	// универсальный способ указать спецификатор в printf для такого указателя
	// -- макрос PRIxPTR.
	bar_func_t *bar_addr = bar;
	printf("bar address=0x%"PRIxPTR"\n", (uintptr_t)bar_addr);

	// Смещаем файловый указатель на p байт -- адрес нашей функции
	// Таким образом, файловый указатель будет указывать на ее код
	if (lseek(fd, (off_t)bar_addr, SEEK_SET) < 0) {
		ret = errno;
		perror("lseek fail");
		goto exit;
	}

	// Читаем заданное количество байт
	// В buf получим код нашей функции bar
	char buf[BYTES_TO_PRINT] = { 0 };
	ret = read(fd, buf, sizeof(buf) / sizeof(buf[0]));
	if (ret != BYTES_TO_PRINT) {
		ret = errno;
		perror("read failed");
		goto exit;
	}

	// Выводим байты кода на экран по 4 байта в строке
	int i;
	for (i = 0; i < BYTES_TO_PRINT; i += 4) {
		//   Вся используемая ниже терминология описана в man 3 printf.
		//
		// * 0x -- строчка, которая выведется as-is
		// * %x -- спецификатор, используемый для вывода unsigned int числа в hex формате
		// * Но мы вывыодим только 1 байт, поэтому нужно использовать специальный length modifier,
		//   который скажет prtinf выводить из int-а только его часть. hh используется для конвертации
		//   в char
		// * Для байтов, у которых в старших разрядах 0, мы хотим вывести его явно:
		//   т.е. для 0x5 увидеть выводи 0x05. Для этого указываем field width = 2,
		//   и flag character = 0. Последний означает заполнять пустоту (мы указали field width 2,
		//   для числа 0x5 будет 1 символ пустоты) нулями.
		printf("0x%02hhx 0x%02hhx 0x%02hhx 0x%02hhx\n", buf[i], buf[i+1], buf[i+2], buf[i+3]);
	}

exit:
	close(fd);
	return ret;
}
