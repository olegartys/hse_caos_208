/* Collatz calculator. Принимает на вход первое положительное число последовательности (назовём его C[0]).
   Следующее число С[n+1] вычисляется так: если предыдущее C[n] чётное, то C[n+1] = C[n]/2, иначе C[n+1] = 3*C[n]+1.
   Программа печатает числа последовательности. При достижении C[...] = 1 программа останавливается.
   Если при вычислениях возникает переполнение, программа печатает нуль и тоже останавливается.
*/

#include "../simpleio_i686.S"

	.text
	.global main
main:
	call readi32

.loop:
	// Проверка четности. test делает логическое и, так что наложим маску
	// 0x1 на младшие 16бит регистра eax. Если получится 0 -- число четное
	test $1, %al
	jz .even

.odd:
	// 3 * C[n] + 1
	mov %eax, %edx
	add %edx, %eax
	add %edx, %eax
	add $1, %eax
	// Если после арифметики значение в eax стало меньше, чем было до,
	// то произошло переполнение.
	cmp %edx, %eax
	jb .overflow

.loop_1:
	cmp $1, %eax
	je .exit_

	// В задаче используются беззнаковые числа, но writei32 печатает их как знаковые.
	// Поэтому на значения последовательности больших 0x7fffffff = max_int, будет
	// выведено отрицательное число
	call writei32
	jmp .loop

.even:
	// Деление или умножение на степень двойки делается через
	// побитовый сдвиг
	shr %eax
	jmp .loop_1

.exit_:
	call finish

.overflow:
	// Самый быстрый способ обнулить регистр
	xor %eax, %eax
	call writei32
	call finish
