/*Объектно-ориентированный ассемблер. “Объектом” назовём структуру
{ int x; int (*method)(int); }. Заведём две “реализации виртуального метода”: функцию, которая удваивает свой аргумент, и функцию, которая прибавляет к нему 1.
Заведём статический пустой массив “объектов” objects достаточно большой ёмкости. На стандартный вход поступают команды:
0 x i (добавить в массив объект с заданным x и указателем на i-ю реализацию метода), i = [0, 1]
1 i (установить objects[i].x = objects[i].method(objects[i].x) и распечатать это число).
*/
#define OBJ_SIZE 8

	// NOTE(olegartys): extern, согласно документации, не обязателен
	.extern obj_arr
	.extern obj_arr_size

	.data
	// Выделяем память под массив, содержащий адреса "реализаций виртуального метода".
	// Это позволит нам отображать индекс "виртуального метода" в его реализацию.
.func_map:
	.long .func_inc, .func_double

	.text
	// Экспортируем символы, чтобы мы могли использовать их в другой единице
	// трансляции -- main.c
	.global obj_arr_append, obj_arr_call
.func_inc:
	// Согласно cdecl, аргументы лежат на стеке.
	// Прибавляем offset 4, потому что на данный момент
	// esp указывает сохраненный EIP -- это адрес возврата,
	// он будет считан инструкцией ret.
	mov 4(%esp), %eax
	inc %eax
	ret

.func_double:
	mov 4(%esp), %eax
	add %eax, %eax
	ret

obj_arr_append:
	// Согласно cdecl, мы внутри функции не должны портить значение регистра EBP,
	// поэтому сохраним его на стек. Сохраним текущее значение esp в ebp и будем
	// использовать ebp для обращения к аргументам функции и локальным переменным.
	//
	// Это стандартный подход, а конструкция ниже называется пролог функции.
	push %ebp
	mov %esp, %ebp

	// Сохраняем ebx на стек, т.к. мы будем его использовать ниже в коде,
	// но, согласно cdecl, мы не должны портить его значение.
	push %ebx

	// Аргументы кладутся на стек вызывающей стороной справа налево
	movl 8(%ebp), %eax // x
	movl 12(%ebp), %ecx // i

	// Читаем адрес "виртуальной функции" по индексу
	// из массива func_map
	movl .func_map(, %ecx, 4), %ebx

	// Сохраняем размер массива в ecx
	movl (obj_arr_size), %ecx
	// Инструкция lea аналогична функции mov, но не читает значение памяти,
	// а только подсчитывает effective address.
	// Здесь мы сохраняем адрес структуры-элемента массива по индексу ecx
	// в регистр edx. edx теперь -- указатель на структуру
	lea obj_arr(, %ecx, OBJ_SIZE), %edx

	// Записываем значение аргумента функции x по 0 смещению в структуру,
	// т.е. в поле элемента структуры x.
	movl %eax, (%edx)

	// Записываем значение адреса "виртуальной функции" по смещению 4 в структуру,
	// т.е. в поле method.
	movl %ebx, 4(%edx)

	// Элемент массива добавлен -- увеличиваем размер.
	// Суффикс l здесь говорит, что по адресу obj_arr_size находится
	// слово длинной long -- 32бита.
	// Иначе компилятор не сможет понять, какого размера слово находится
	// по этому адресу.
	incl (obj_arr_size)

	// Восстанавливаем значение регистра ebx
	pop %ebx

	// Восстанавливаем значение регистра ebp.
	// Конструкция ниже называется эпилог.
	// Она симметрична прологу.
	pop %ebp
	ret

obj_arr_call:
	movl 4(%esp), %ecx // i

	// Получаем значение поля method структуры с индексом ecx в регистр edx.
	// Поле находится по offset-у 4байт.
	// Аналогично можно переписать так: mov obj_arr+4(, %ecx, OBJ_SIZE), %edx
	mov $4, %eax
	mov obj_arr(%eax, %ecx, OBJ_SIZE), %edx
	test %edx, %edx
	jz .obj_arr_call.null_method

	// Получаем значение поля x структуры с индексом ecx
	mov obj_arr(, %ecx, OBJ_SIZE), %eax

	// Вызываем method по значению из регистра edx
	// Такой вызов называется indirect call: адрес не известен на момент компиляции
	// и читается либо из регистра, либо из какого-то адреса в памяти.
	// При indirect call ставится *
	//
	// Кладем на стек значение x -- аргумент функции
	push %eax
	call *%edx
	// После push esp сдвинулся, возвращаем его обратно
	add $4, %esp

	// method поменял eax -- сохраняем его в структуру-элемент массива.
	mov %eax, obj_arr(, %ecx, OBJ_SIZE)

	// Возвращаемое значение должно сохраняться в eax, согласно cdecl.
	ret

.obj_arr_call.null_method:
	mov $-1, %eax
	ret
